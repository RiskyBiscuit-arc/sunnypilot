name: sunnypilot publish and notify

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["sunnypilot prebuilt action"]
    types:
      - completed

env:
  OUTPUT_DIR: ${{ github.workspace }}/output
  CI_DIR: ${{ github.workspace }}/release/ci
  PUBLIC_REPO_URL: "https://github.com/sunnypilot/sunnypilot"
  VERBOSE_LOGGING: ${{ vars.VERBOSE_LOGGING || 'true' }}

jobs:
  prepare:
    runs-on: ubuntu-24.04
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch')
    outputs:
      should_publish: ${{ steps.get-build-outputs.outputs.should_publish }}
      new_branch: ${{ steps.get-build-outputs.outputs.new_branch }}
      version: ${{ steps.get-build-outputs.outputs.version }}
      extra_version_identifier: ${{ steps.get-build-outputs.outputs.extra_version_identifier || github.event.workflow_run.id}}
      branch_name: ${{ steps.get-build-outputs.outputs.branch_name }}
    steps:
      - name: Find latest successful build run
        if: github.event_name == 'workflow_dispatch'
        id: find-run
        uses: actions/github-script@v7
        env:
          VERBOSE: ${{ env.VERBOSE_LOGGING }}
        with:
          script: |
            const verbose = process.env.VERBOSE === 'true';
            const log = msg => verbose && console.log('üîç VERBOSE:', msg);
            
            const branch = context.ref.replace('refs/heads/', '');
            log(`Looking for builds on branch: ${branch}`);
            
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });
            
            let targetBranch = branch;
            if (prs.data.length > 0) {
              log(`Found PR from branch ${branch}`);
              targetBranch = prs.data[0].head.ref;
              log(`Using PR head branch: ${targetBranch}`);
            }
            
            log(`Searching for successful builds on branch: ${targetBranch}`);
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'sunnypilot-build-prebuilt.yaml',
              branch: targetBranch,
              status: 'success',
              per_page: 1
            });
            
            if (runs.data.workflow_runs.length === 0) {
              log(`No successful builds found for branch ${targetBranch}`);
              core.setFailed(`No successful builds found for branch ${targetBranch}`);
              return;
            }
            
            const latestRun = runs.data.workflow_runs[0];
            log(`Found latest successful build ID: ${latestRun.id}`);
            core.setOutput('run_id', latestRun.id);

      - name: Download workflow artifact from workflow_run
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: prebuilt
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
        
      - name: Download workflow artifact from workflow_dispatch
        if: github.event_name == 'workflow_dispatch'
        uses: actions/download-artifact@v4
        with:
          name: prebuilt
          run-id: ${{ steps.find-run.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get build job outputs
        id: get-build-outputs
        uses: actions/github-script@v7
        env:
          VERBOSE: ${{ env.VERBOSE_LOGGING }}
        with:
          script: |
            const verbose = process.env.VERBOSE === 'true';
            const log = msg => verbose && console.log('üîç VERBOSE:', msg);

            const runId = '${{ github.event_name }}' === 'workflow_run' 
              ? context.payload.workflow_run.id
              : ${{ steps.find-run.outputs.run_id }};

            log(`Getting job outputs for run ID: ${runId}`);

            try {
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });

              log('Workflow run details:', JSON.stringify(run.data, null, 2));

              const jobs = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });

              const buildJob = jobs.data.jobs.find(j => j.name === 'build');
              if (buildJob) {
                log('Build job details:', JSON.stringify(buildJob, null, 2));

                // Try to get artifacts
                const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runId
                });

                log('Artifacts:', JSON.stringify(artifacts.data, null, 2));

                if (buildJob.steps) {
                  const envStep = buildJob.steps.find(s => s.name === 'Set environment variables');
                  if (envStep) {
                    log('Environment step:', JSON.stringify(envStep, null, 2));
                  }

                  // Log all step names and their conclusions
                  log('All steps:');
                  buildJob.steps.forEach(step => {
                    log(`Step ${step.name}: ${step.conclusion}`);
                  });
                }
              }
            } catch (error) {
              log('Error:', error.message);
              core.setFailed(error.message);
            }

  publish:
    needs: prepare
    runs-on: ubuntu-24.04
    if: needs.prepare.outputs.should_publish == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Untar prebuilt
        run: |
          mkdir -p ${{ env.OUTPUT_DIR }}
          tar xzf prebuilt.tar.gz -C ${{ env.OUTPUT_DIR }}

      - name: Configure Git
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

      - name: Publish to Public Repository
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ env.VERBOSE_LOGGING }}" = "true" ]; then
            echo "üîç VERBOSE: Starting publish process"
            echo "üîç VERBOSE: Workspace: ${{ github.workspace }}"
            echo "üîç VERBOSE: Output directory: ${{ env.OUTPUT_DIR }}"
            echo "üîç VERBOSE: New branch: ${{ needs.prepare.outputs.new_branch }}"
            echo "üîç VERBOSE: Version: ${{ needs.prepare.outputs.version }}"
          fi
          
#          ${{ env.CI_DIR }}/publish.sh \
#            "${{ github.workspace }}" \
#            "${{ env.OUTPUT_DIR }}" \
#            "${{ needs.prepare.outputs.new_branch }}" \
#            "${{ needs.prepare.outputs.version }}" \
#            "https://x-access-token:${{github.token}}@github.com/sunnypilot/sunnypilot.git" \
#            "-${{ needs.prepare.outputs.extra_version_identifier }}"

  notify:
    needs: [prepare, publish]
    runs-on: ubuntu-24.04
    if: always() && needs.prepare.result == 'success'
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq gettext-base

      - name: Check notification branch
        id: check-branch
        run: |
          # Get branch name from prepare job
          export branch_name="${{ needs.prepare.outputs.branch_name }}"
          echo "üîç Current branch: $branch_name"

          echo "üìã Checking against dev-feedback notification branches list..."
          echo "Current notifiable branches: ${{ vars.DEV_FEEDBACK_NOTIFICATION_BRANCHES }}"
          echo ""

          IFS=',' read -ra BRANCHES <<< "${{ vars.DEV_FEEDBACK_NOTIFICATION_BRANCHES }}"
          for branch in "${BRANCHES[@]}"; do
            if [ "$branch_name" = "$branch" ]; then 
              echo "‚úÖ Match found! '$branch_name' will notify to dev-feedback channel"
              echo "is_dev_feedback_notifiable_branch=true" >> $GITHUB_OUTPUT
              break
            fi
          done

          echo ""
          echo "----   ‚ÑπÔ∏è To update the list of branches that notify to dev-feedback   -----"
          echo ""
          echo "1. Go to: ${{ github.server_url }}/${{ github.repository }}/settings/variables/actions/DEV_FEEDBACK_NOTIFICATION_BRANCHES"
          echo "2. Current value: [${{ vars.DEV_FEEDBACK_NOTIFICATION_BRANCHES }}]"
          echo "3. Update as needed (comma-separated list with no spaces)"

      - name: Send Discord Notification
        env:
          DISCORD_WEBHOOK: ${{ steps.check-branch.outputs.is_dev_feedback_notifiable_branch == 'true' && needs.publish.result != 'skipped' && secrets.DISCORD_DEV_FEEDBACK_CHANNEL_WEBHOOK || secrets.DISCORD_DEV_PRIVATE_CHANNEL_WEBHOOK }}
        run: |
          if [ "${{ env.VERBOSE_LOGGING }}" = "true" ]; then
            echo "üîç VERBOSE: Preparing Discord notification"
            echo "üîç VERBOSE: Using webhook type: ${{ steps.check-branch.outputs.is_dev_feedback_notifiable_branch == 'true' && 'dev-feedback' || 'private' }}"
            echo "üîç VERBOSE: Publish result: ${{ needs.publish.result }}"
          fi
          
          TEMPLATE='${{ needs.publish.result == 'skipped' && vars.DISCORD_INTERNAL_WORKFLOW_ALERT || vars.DISCORD_GENERAL_UPDATE_NOTICE }}'
          export VERSION="${{ needs.prepare.outputs.version }}"
          export branch_name="${{ needs.prepare.outputs.branch_name }}"
          export new_branch="${{ needs.prepare.outputs.new_branch }}"
          export extra_version_identifier="${{ needs.prepare.outputs.extra_version_identifier }}"
          
          echo ${TEMPLATE} | envsubst | jq -c '.' | tee payload.json
#          curl -X POST -H "Content-Type: application/json" -d @payload.json $DISCORD_WEBHOOK